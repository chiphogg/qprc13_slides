---
title       : 
subtitle    : 
author      : Charles Hogg
job         : Google, Inc.
framework   : io2012        # {io2012, html5slides, shower, dzslides, ...}
highlighter : highlight.js  # {highlight.js, prettify, highlight}
hitheme     : tomorrow      # 
widgets     : [mathjax]     # {mathjax, quiz, bootstrap}
mode        : selfcontained # {standalone, draft}

```{r setup, include=FALSE}
require(knitr)
require(gppois)
require(ggplot2)
require(Cairo)
opts_chunk$set(fig.width=13, fig.height=5, warning=FALSE, cache=TRUE,
  dev='CairoPNG', echo=FALSE)
theme_set(theme_classic(40))
knit_hooks$set(webgl = function(before, options, envir) {
  library(rgl)
  ## after a chunk has been evaluated
  if (before || rgl.cur() == 0) return()  # no active device
  name <- sprintf('rgl_%s.html', options$label)
  par3d(windowRect = 100 + options$dpi * c(0, 0,
                                           options$fig.width,
                                           options$fig.height))
  Sys.sleep(.05) # need time to respond to window size change
  writeLines(c('%WebGL%', '<script>webGLStart();</script>'), tpl <- tempfile())
  writeWebGL(dir = dirname(name), filename = name, template = tpl)
  sprintf('<iframe src="%s" width="%s" height="%s"></iframe>', name,
    options$dpi * options$fig.width, options$dpi * options$fig.height)
})
gif.output.directory <- paste(getwd(), 'custom', sep='/')
```

---

# Overview

The basic story is this.

We've got a metal plate, and we stretch it.  So there's some amount of strain at
every point on this surface.  We've measured this strain function at a bunch of
points, but we wish we knew it everywhere.  We wish we knew this _strain
surface_, if you like.  We have some idea about it, but we're not completely
certain.

So, first question: how uncertain _are_ we?  You see we'll need a sensible way
to _quantify_ uncertainty in _continuous functions_.

---

# Probabilities for functions

Great narrative for great justice!

1. What we wish we had
  - _Individual_ random quantities (like rolls of a die) are easier to understand
  - Show a bunch of random draws of functions.  ("WAT.")
    - Here, the probabilities don't matter; what matters are the functions in the distribution.
2. Simpler case: two random numbers.
  - Show on scatterplot.
    - Familiar, and great, visualization!  But it **doesn't scale**.
3. Simpler case; alternative view
  - Show side-by-side with scatterplot: random variables next to each other
    - Connect them by lines... hmm!  Suggestive!!
4. Lots of variables
5. Return to scatterplot view
  - nice animated gif

Maybe then talk about GPs: use the simplest multivariate probability distribution.

---

## Probability example: rolling dice

TODO: plot this in a way which suggests individual draws.  Maybe scatterplot?
vertical axis: 2 through 12.  Horizontal axis: index.

```{r dice.plot.function}
global_dice_rolls <<- c()
dice_plot <- function(n, rolls) {
  set.seed(1)
  n.prime <- n - length(global_dice_rolls)
  if (n.prime < 0) return (NULL)
  global_dice_rolls <<- c(global_dice_rolls,
    round(runif(n=n.prime, min=0.5, max=6.5))
    + round(runif(n=n.prime, min=0.5, max=6.5)))
  d <- data.frame(x=global_dice_rolls)
  p <- (ggplot(data=d, aes(x=x))
    + geom_histogram(binwidth=1, colour='white', origin=0.5)
    + scale_x_continuous("Total", limits=c(1, 13),
      breaks=seq(from=2, to=12, by=2))
    + scale_y_continuous("", breaks=rolls)
    + ggtitle(sprintf("Rolling 2 dice %d times", n))
    )
  return (p)
}
```

```{r make.gif, include=FALSE}
set.seed(5)
library(animation)
saveGIF({
  # Make the animation
  rolls <- as.vector(outer(c(2, 5, 10), 10^(0:3)))
  rolls <- c(rolls, rep(tail(rolls, n=1), 4))
  for (i in rolls) {
    print(dice_plot(i, rolls))
  }
}, movie.name='dice.gif',
outdir=gif.output.directory,
clean=TRUE, interval=1.2, ani.dev='CairoPNG',
ani.width=150 * 6.5, ani.height=150 * 3.5)
```

<img src="custom/dice.gif">

---

## Random functions (?)

```{r random.function.function, include=FALSE}
PlotRandomFunctions <- function(i, n) {
  # Generate n random functions, and plot the first i of them, highlighting the
  # i'th one.
  i <- min(i, n)
  set.seed(2)
  require(gppois)
  require(ggplot2)
  N <- 200
  X <- seq(from=0, to=6, length.out=N)
  Cov <- CovarianceSE(ell=1, sigma.f=1)
  K <- Cov$K.specific(X=X) + 1e-8 * diag(N)
  L <- t(chol(K))
  seeds <- matrix(rnorm(n=N*n), nrow=N)
  d_master <- data.frame(y=as.vector(L %*% seeds), x=X, i=rep(1:n, each=N))
  d_old <- d_master[which(d_master$i < i), ]
  d_new <- d_master[which(d_master$i == i), ]
  old.size <- 1.2
  new.size <- old.size * 1.5
  p <- (ggplot(data=d_old)
    + geom_line(aes(y=y, x=x, group=i), size=old.size, colour='grey50')
    + geom_line(data=d_new, aes(y=y, x=x), size=new.size, colour='red')
    + scale_y_continuous("", limits=3*c(-1, 1))
    )
  return (p)
}
```

```{r random.function.animation, include=FALSE}
set.seed(1)
library(animation)
library(gridExtra)
saveGIF({
  n <- 11
  for (i in 1:(n + 1)) {
    print(PlotRandomFunctions(i, n))
  }
}, movie.name='random_functions.gif',
outdir=gif.output.directory,
clean=TRUE, interval=2, ani.dev='CairoPNG',
ani.width=150 * 3.5, ani.height=150 * 3.5)
```

<img src="custom/random_functions.gif">

---

## Two variables

```{r scatterplot.function}
twod_scatterplot <- function(n, old=0) {
  # A 2d scatterplot of draws from a bivariate normal.
  #
  # Args:
  #   n: The number of points to plot
  #   old: The number of points considered "old" (might be greyed out).
  set.seed(1)
  covariance <- 0.8
  L <- t(chol(matrix(c(1, covariance, covariance, 1), nrow=2)))
  x <- L %*% matrix(rnorm(n=2 * n), nrow=2)
  d <- data.frame(x=x[1, ], y=x[2, ], type=c(rep('a', old), rep('b', n - old)))
  lim <- 3
  p <- (ggplot(data=d, aes(x=x, y=y, colour=type))
    + geom_point(size=2)
    + scale_x_continuous("X1", limits=c(-lim, lim))
    + scale_y_continuous("X2", limits=c(-lim, lim))
    + scale_colour_manual(values=c(a='grey40', b='black'))
    + theme(legend.position='none')
    )
  return (p)
}
```

```{r make.scatterplot.gif, include=FALSE}
set.seed(1)
library(animation)
saveGIF({
  old.num <- 0
  num <- 20
  for (i in 1:4) {
    print(twod_scatterplot(num, old.num))
    old.num <- num
    num <- num * 3
  }
  print(twod_scatterplot(num, old.num))
}, movie.name='2d_scatterplot.gif',
outdir=gif.output.directory,
clean=TRUE, interval=4, ani.dev='CairoPNG',
ani.width=150 * 3.5, ani.height=150 * 3.5)
```

<img src="custom/2d_scatterplot.gif">

---

## Two variables: alternative view

```{r side.by.side.function}
twod_side_by_side <- function(n, old=0) {
  # A 2d scatterplot of draws from a bivariate normal.
  #
  # Args:
  #   n: The number of points to plot
  #   old: The number of points considered "old" (might be greyed out).
  set.seed(1)
  covariance <- 0.8
  L <- t(chol(matrix(c(1, covariance, covariance, 1), nrow=2)))
  x <- L %*% matrix(rnorm(n=2 * n), nrow=2)
  d <- data.frame(X1=x[1, ], X2=x[2, ], type=c(rep('a', old), rep('b', n - old)))
  d$id <- 1:nrow(d)
  require(reshape2)
  d_melt <- melt(d, id.vars=c('id', 'type'))
  lim <- 3
  p <- (ggplot(data=d_melt, aes(x=variable, y=value, group=id, colour=type))
    + geom_point(size=4)
    + geom_line(size=1.5)
    + scale_x_discrete("variable")
    + scale_y_continuous("value", limits=c(-lim, lim))
    + scale_colour_manual(values=c(a='grey40', b='black'))
    + theme(legend.position='none')
    )
  return (p)
}
```

```{r make.side.by.side.gif, include=FALSE}
set.seed(1)
library(animation)
saveGIF({
  old.num <- 0
  num <- 5
  for (i in 1:3) {
    require(gridExtra)
    grid.arrange(ncol=2
      , widths=c(3.5, 3.0)
      , twod_scatterplot(num, old.num)
      , twod_side_by_side(num, old.num)
      )
    old.num <- num
    num <- num * 3
  }
  grid.arrange(ncol=2
    , widths=c(3.5, 3.0)
    , twod_scatterplot(num, old.num)
    , twod_side_by_side(num, old.num)
    )
}, movie.name='2_vars_side_by_side.gif',
outdir=gif.output.directory,
clean=TRUE, interval=4, ani.dev='CairoPNG',
ani.width=150 * 6.5, ani.height=150 * 3.5)
```

<img src="custom/2_vars_side_by_side.gif">

---

## Many variables

```{r many.side.by.side.function, cache=FALSE}
many_side_by_side <- function(k, n, i) {
  set.seed(3)
  X <- 1:k
  K <- 0.9 ^ abs(outer(X, X, function(x, y) (x - y) ^ 2))
  L <- t(chol(K))
  x <- L %*% matrix(rnorm(n=k * n), nrow=k)
  d <- data.frame(X=t(x))
  d$id <- 1:nrow(d)
  d$highlight = 'no'
  d$highlight[which(d$id == i)] = 'yes'
  require(reshape2)
  d_melt <- melt(d[which(d$id <= i), ], id.vars=c('id', 'highlight'))
  lim <- 3
  p <- (ggplot(data=d_melt, aes(x=as.numeric(substring(variable, 3)), y=value, group=id, colour=highlight))
    + geom_point(size=4)
    + geom_line(size=1.5)
    + scale_x_continuous("variable", breaks=1:k, labels=paste("X", 1:k, sep=''))
    + scale_y_continuous("value", limits=c(-lim, lim))
    + scale_colour_manual("", values=c(yes='red', no='grey50'))
    + theme(legend.position='none')
    )
  return (p)
}
```

```{r make.many.side.by.side.gif, include=FALSE}
set.seed(1)
library(animation)
saveGIF({
  k <- 15
  n <- 10
  for (i in 1:(n + 1)) {
    print(many_side_by_side(k, n, i))
  }
}, movie.name='many_vars.gif',
outdir=gif.output.directory,
clean=TRUE, interval=4, ani.dev='CairoPNG',
ani.width=150 * 6.5, ani.height=150 * 3.5)
```

<img src="custom/many_vars.gif">

---

## Covariance is Key

```{r slider.function, include=FALSE, cache=FALSE}
SlidingVariables <- function(n_lines, n_points,
  x=seq(from=0, to=6, length.out=200), i1=round(length(x) * 0.2), i2) {
  # Plots n_lines "random functions", and a scatterplot (with n_points points)
  # of function values at x1 and x2.
  set.seed(2)
  require(gppois)
  require(ggplot2)
  N <- length(x)
  Cov <- CovarianceSE(ell=0.3 * diff(range(x)), sigma.f=1)
  K <- Cov$K.specific(X=x) + 1e-8 * diag(N)
  L <- t(chol(K))
  seeds <- matrix(rnorm(n=N*n_lines), nrow=N)
  d_lines <- data.frame(y=as.vector(L %*% seeds), x=x, i=rep(1:n_lines, each=N))
  xi <- c(x[i1], x[i2])
  d_vlines <- data.frame(x=xi)

  # Scatterpoints sampled from the lines.
  d_sampled_pts <- data.frame(i=1:n_lines
    , x1=d_lines$y[which(d_lines$x == x[i1])]
    , x2=d_lines$y[which(d_lines$x == x[i2])]
    )
  # Generate more scatterpoints with the same covariance.
  seeds.many <- matrix(rnorm(n=N * n_points), nrow=N)
  d_many_points <- data.frame(t(L %*% seeds.many)[, c(i1, i2)])
  point_base_size <- 1

  common_options <- list(scale_colour_brewer("", palette="Set3")
    , theme(legend.position='none')
    )
  p_lines <- (ggplot(data=d_lines)
    + geom_line(aes(y=y, x=x, group=i, colour=as.factor(i)), size=2)
    + geom_vline(data=d_vlines, aes(xintercept=x))
    + scale_x_continuous("", breaks=d_vlines$x, labels=c('X1', 'X2'))
    + scale_y_continuous("", limits=3*c(-1, 1))
    + common_options
    )
  p_scatter <- (ggplot(data=d_many_points, aes(x=x1, y=x2))
    + geom_point(aes(x=X1, y=X2), size=point_base_size, colour='grey70')
    + geom_point(data=d_sampled_pts
      , colour='black'
      , size=5.5 * point_base_size
      )
    + geom_point(data=d_sampled_pts
      , aes(colour=as.factor(i))
      , size=4.0 * point_base_size
      )
    + scale_x_continuous("X1", limits=3*c(-1, 1))
    + scale_y_continuous("X2", limits=3*c(-1, 1))
    + coord_fixed(ratio=1)
    + common_options
    )
  return (list(lines=p_lines, scatter=p_scatter))
}
```

```{r slider.figure, include=FALSE, cache=FALSE}
set.seed(1)
library(animation)
n_frames <- 50
N <- 200  # Number of points.
X <- seq(from=0, to=1, length.out=N)
di_min <- N * 0.05
offset <- floor(0.5 * di_min)
distance <- ((0.5 * (N - di_min) - 1)
  * sin(pi * seq(from=1 / n_frames, to=1, length.out=n_frames)) ^ 2)
i_mid <- round(N / 2)
i <- data.frame(i1=i_mid - offset - distance, i2=i_mid + offset + distance)
di <- round(di_min + (N - i1 - di_min) * fraction)
saveGIF({
  for (a in 1:nrow(i)) {
    sv <- SlidingVariables(n_lines=12, n_points=1000, x=X, i1=i$i1[a], i2=i$i2[a])
    grid.arrange(ncol=2
      , sv$lines
      , sv$scatter
      )
  }
}, movie.name='slide_and_scatter.gif',
outdir=gif.output.directory,
clean=TRUE, interval=0.1, ani.dev='CairoPNG',
ani.width=150 * 6.5, ani.height=150 * 3.5)
```

<img src="custom/slide_and_scatter.gif">

---

## What's the probability of a function?

---

## Another view

Gaussian process machinery:
  - There's some function you wish you knew.
  - Give the machinery some arbitrary number of points where you know the
    function (it's fine if they're noisy).
  - Ask it for the values of the function at some other set of points
    - The key is: look at those values **simultaneously**.

---

## Also worth mentioning

Gaussian processes were used by the BEST collaboration (solved problems with
time series, etc.)

---

# Steel strain results


```{r steel-strain-vars, include=FALSE}
load("custom/trained.RO")
x.gap.surface <- GriddedConvexHull(X=d.gap$X, spacing=0.2)
post.gap <- M.aniso$PosteriorInterval(d=d.strain, X.out=x.gap.surface, num.sd=1)
post.gap.wide <- M.aniso$PosteriorInterval(d=d.strain, X.out=x.gap.surface, num.sd=3)
M.aniso$SetNoiseBounds(sigma.vals=2e-6)
L.strain <- M.aniso$L(d=d.strain, X.out=x.gap.surface)
```

```{r strain-datapoints, webgl=TRUE, fig.height=7}
d.strain$Plot2D(dist.factor=0.15, max.points=Inf, Y.scale=500)
```
What do I actually want to show?

  1. mean surface
  2. +- 1 sigma: show low uncertainty
  3. +- 1 sigma with actual datapoints
  4. +- 2 (or 3) sigma: no outliers?

Alternative slide: animations?  Only if I have time.

---

## Steel strain results: mean surface

```{r fig.height=7, webgl=TRUE}
d.strain$Plot2D(dist.factor=0.15, max.points=Inf, Y.scale=500)
PlotSurface(X=x.gap.surface, Y=post.gap$mean)
```

---

## Steel strain results: with 1-sigma uncertainty

```{r fig.height=7, webgl=TRUE}
d.strain$Plot2D(dist.factor=0.15, max.points=Inf, Y.scale=500)
PlotSurface(X=x.gap.surface, Y=post.gap$mean)
PlotSurface(X=x.gap.surface, Y=post.gap$upper, color='blue', alpha=0.3)
PlotSurface(X=x.gap.surface, Y=post.gap$lower, color='red', alpha=0.3)
```

---

## Steel strain results: true datapoints

```{r fig.height=7, webgl=TRUE}
d.strain$Plot2D(dist.factor=0.15, max.points=Inf, Y.scale=500)
PlotSurface(X=x.gap.surface, Y=post.gap$mean)
PlotSurface(X=x.gap.surface, Y=post.gap$upper, color='blue', alpha=0.6)
PlotSurface(X=x.gap.surface, Y=post.gap$lower, color='red', alpha=0.6)
d.gap$Plot2D(dist.factor=0.15, max.points=Inf, clear=FALSE, col="grey")
```

---

# Feedback to the experiment

```{r common-parameters, include=FALSE, cache=FALSE}
diameter_to_show <- 8
display_range <- diameter_to_show * c(-1, 1) * 0.5
data_size <- 2.0            # size of datapoints
gap_size <- 3 * data_size   # size of gap points
gap_border_size <- gap_size * 1.3
data(steelStrain)
h <- diff(range(c(steelStrain$exx, steelStrainGap$exx)))

aggregate_line_size <- 1

uncertainty_log_breaks <- -c(7, 5, 3)
uncertainty_log_labels <- eval(parse(text=paste(sep='', "expression("
      , paste("10^", -c(7, 5, 3), collapse=", ", sep='')
      , ")")))

AnimSeq <- function(from, to, step, delay) {
  s <- seq(from=from, to=to, by=step)
  d <- delay - 1
  return (c(rep(from, d), s, rep(to, d), rev(s)))
}
animation_keys <- AnimSeq(6, 3, -0.5, 5)
```

```{r gap.size.analysis.functions, include=FALSE, cache=FALSE}
load('./custom/results.RO')

PlotUncertainty <- function(results, gap.size) {
  # Plot the uncertainty in the predicted gap strain points.
  p <- (ggplot(data=as.data.frame(results[[gap.size]]$data$X), aes(x=X, y=Y))
    + geom_point(size=data_size)
    + geom_point(data=results[[gap.size]]$predicted, size=gap_border_size,
      aes(x=X.X, y=X.Y), colour='black')
    + geom_point(data=results[[gap.size]]$predicted, size=gap_size,
      aes(x=X.X, y=X.Y, colour=(upper-mean)))
    + scale_x_continuous("", limits=display_range)
    + scale_y_continuous("", limits=display_range)
    + scale_colour_gradientn(expression(sigma)
      , limits=0.2 * h * c(1e-5, 1)
      , trans='log'
      , colours=c("green", "yellow", "red")
      , breaks=10^(uncertainty_log_breaks)
      , labels=uncertainty_log_labels
      )
    + coord_fixed(ratio=1)
    + ggtitle(expression(paste("Uncertainty (1-", sigma, ")")))
    )
  return (p)
}

PlotAggregateUncertainty <- function(results, gap.size) {
  # Plot summary statistics (max, median, mean) for the uncertainty at each gap
  # size, highlighting one gap size above the rest.
  N <- length(results)

  # Compute mean, median, and max uncertainty for each gap size.
  unc_max <- c()
  unc_median <- c()
  unc_mean <- c()
  for (gap in names(results)) {
    unc_max <- c(unc_max, max(
        results[[gap]]$predicted$upper - results[[gap]]$predicted$mean))
    unc_mean <- c(unc_mean, mean(
        results[[gap]]$predicted$upper - results[[gap]]$predicted$mean))
    unc_median <- c(unc_median, median(
        results[[gap]]$predicted$upper - results[[gap]]$predicted$mean))
  }

  # Construct data frame suitable for plotting.
  d_wide <- data.frame(gap=names(results),
    max=unc_max, mean=unc_mean, median=unc_median)
  require(reshape2)
  d <- melt(d_wide, id.vars="gap")
  d$highlight <- 'no'
  d$highlight[which(d$gap == gap.size)] <- 'yes'

  # Construct and return the plot.
  point_size <- 2
  require(ggplot2)
  p <- (ggplot(data=d, aes(x=as.numeric(as.character(gap)), y=value))
    + geom_line(aes(colour=variable))
    + geom_point(aes(size=highlight), show_guide=FALSE)
    + scale_size_manual(values=c(no=point_size, yes=2 * point_size))
    + scale_x_continuous("Gap (mm)", breaks=3:6, labels=3:6)
    + scale_y_log10(""
      , breaks=10^(uncertainty_log_breaks)
      , labels=uncertainty_log_labels
      )
    + scale_colour_brewer("", palette="Set1")
    + ggtitle("Summary")
    )
  return (p)
}

PlotError <- function(results, gap.size) {
  # Plot the difference between the true gap strain and the predicted values.
  results[[gap.size]]$predicted$error <- (
    results[[gap.size]]$predicted$mean - results[[gap.size]]$gap$dpts)
  p <- (ggplot(data=as.data.frame(results[[gap.size]]$data$X), aes(x=X, y=Y))
    + geom_point(size=data_size)
    + geom_point(data=results[[gap.size]]$predicted, size=gap_border_size,
      aes(x=X.X, y=X.Y), colour='black')
    + geom_point(data=results[[gap.size]]$predicted, size=gap_size,
      aes(x=X.X, y=X.Y, colour=error))
    + scale_x_continuous("", limits=display_range)
    + scale_y_continuous("", limits=display_range)
    + scale_colour_gradient2("Error", limits=1.4e-3 * c(-1, 1), breaks=c(-0.001, 0, 0.001))
    + coord_fixed(ratio=1)
    + ggtitle("Predicted minus actual")
    )
  return (p)
}

PlotAggregateError <- function(results, gap.size) {
  d <- data.frame()
  for (gap in names(results)) {
    d <- rbind(d
      , data.frame(gap=gap
        , error=results[[gap]]$predicted$mean - results[[gap]]$gap$dpts
        )
      )
  }
  d$highlight <- 'no'
  d$highlight[which(d$gap == gap.size)] <- 'yes'
  p <- (ggplot(data=d, aes(x=error, colour=gap))
    + stat_ecdf(aes(size=highlight), show_guide=FALSE)
    + scale_x_log10()
    + scale_y_continuous()
    + scale_colour_brewer(palette="Set1")
    + scale_size_manual(values=c(
        no=aggregate_line_size, yes=2 * aggregate_line_size))
    + ggtitle("CDFs")
    )
  return (p)
}

PlotNormalizedError <- function(results, gap.size) {
  # Plot the ratio between the error and the uncertainty.
  results[[gap.size]]$predicted$error <- (
    results[[gap.size]]$predicted$mean - results[[gap.size]]$gap$dpts)
  p <- (ggplot(data=as.data.frame(results[[gap.size]]$data$X), aes(x=X, y=Y))
    + geom_point(size=data_size)
    + geom_point(data=results[[gap.size]]$predicted, size=gap_border_size,
      aes(x=X.X, y=X.Y), colour='black')
    + geom_point(data=results[[gap.size]]$predicted, size=gap_size,
      aes(x=X.X, y=X.Y, colour=error / (upper - mean)))
    + scale_x_continuous("", limits=display_range)
    + scale_y_continuous("", limits=display_range)
    + scale_colour_gradient2("Error", limits=3 * c(-1, 1), breaks=c(-3, -1, 1, 3))
    + coord_fixed(ratio=1)
    )
  return (p)
}

PlotAggregateNormalizedError <- function(results, gap.size) {
  # Plot the ratio between the error and the uncertainty.
  results[[gap.size]]$predicted$error <- (
    results[[gap.size]]$predicted$mean - results[[gap.size]]$gap$dpts)
  d <- data.frame()
  for (gap in names(results)) {
    d <- rbind(d
      , data.frame(gap=gap
        , predicted=results[[gap]]$predicted$mean
        , actual=results[[gap]]$gap$dpts
        )
      )
  }
  d$highlight <- 'no'
  d$highlight[which(d$gap == gap.size)] <- 'yes'
  p <- (ggplot(data=d, aes(x=predicted, y=actual, colour=gap))
    + geom_line(aes(size=highlight))
    + scale_x_continuous("")
    + scale_y_continuous("")
    + scale_size_manual(values=c(
        no=aggregate_line_size, yes=2 * aggregate_line_size))
    + coord_fixed(ratio=1)
    + ggtitle("Think more carefully about this plot!")
    )
  return (p)
}
```

---

## Gap width: ripe for tuning

<object data="./inkscape/beam_1_straight.svg" type="image/svg+xml"></object>

---

## Gap width: ripe for tuning

<object data="inkscape/beam_2_tilted.svg" type="image/svg+xml"></object>

---

## Uncertainty vs. gap size

```{r gap.size.uncertainty, include=FALSE}
set.seed(1)
library(animation)
saveGIF({
  for (i in c(animation_keys, animation_keys[1])) {
    print(PlotUncertainty(results, sprintf("%.1f", i)))
  }
}, movie.name='uncertainty.gif',
outdir=gif.output.directory,
clean=TRUE, interval=0.4, ani.dev='CairoPNG',
ani.width=150 * 3.5, ani.height=150 * 3.5)
```

<img src="custom/uncertainty.gif">

---

## Uncertainty vs. gap size: cumulative statistics

```{r gap.size.uncertainty2, include=FALSE}
set.seed(1)
library(animation)
require(gridExtra)
saveGIF({
  for (i in c(animation_keys, animation_keys[1])) {
    grid.arrange(ncol=2
      , widths=c(3.5, 3.0)
      , PlotUncertainty(results, sprintf("%.1f", i))
      , PlotAggregateUncertainty(results, sprintf("%.1f", i))
      )
  }
}, movie.name='uncertainty2.gif',
outdir=gif.output.directory,
clean=TRUE, interval=0.4, ani.dev='CairoPNG',
ani.width=150 * 6.5, ani.height=150 * 3.5)
```

<img src="custom/uncertainty2.gif">

---

## Error vs. gap size

```{r gap.size.error, include=FALSE}
set.seed(1)
library(animation)
saveGIF({
  for (i in animation_keys) {
    print(PlotError(results, sprintf("%.1f", i)))
  }
}, movie.name='error.gif',
outdir=gif.output.directory,
clean=TRUE, interval=0.4, ani.dev='CairoPNG',
ani.width=150 * 3.5, ani.height=150 * 3.5)
```

<img src="custom/error.gif">

---

## Error vs. gap size: cumulative statistics

```{r gap.size.error2, include=FALSE}
set.seed(1)
library(animation)
require(gridExtra)
saveGIF({
  for (i in c(animation_keys, animation_keys[1])) {
    grid.arrange(ncol=2
      , widths=c(3.5, 3.0)
      , PlotError(results, sprintf("%.1f", i))
      , PlotAggregateError(results, sprintf("%.1f", i))
      )
  }
}, movie.name='error2.gif',
outdir=gif.output.directory,
clean=TRUE, interval=0.4, ani.dev='CairoPNG',
ani.width=150 * 6.5, ani.height=150 * 3.5)
```

<img src="custom/error2.gif">

---

## Normalized error vs. gap size

```{r gap.size.normalized.error, include=FALSE}
set.seed(1)
library(animation)
saveGIF({
  for (i in animation_keys) {
    print(PlotNormalizedError(results, sprintf("%.1f", i)))
  }
}, movie.name='normalized_error.gif',
outdir=gif.output.directory,
clean=TRUE, interval=0.4, ani.dev='CairoPNG',
ani.width=150 * 3.5, ani.height=150 * 3.5)
```

<img src="custom/normalized_error.gif">

---

## Rutherford's criticism

(pic of Rutherford)

"If your experiment needs statistics, you ought to have done a better experiment."

Response: "Better statistics can lead you to that better experiment"

(Show as memes?  Pic of Bayes...)

---

# Conclusions
